<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Predictive Duel NFT Minter</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 500px; margin: 2rem auto; }
        button { margin: .5rem 0; padding: .75rem 1.5rem; font-size: 1rem; }
        input { width: 4rem; margin-left: .5rem; }
        span.cost { margin-left: .5rem; font-weight: bold; }
        #account { margin-bottom: 1rem; font-weight: bold; }
        table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
        th, td { border: 1px solid #ccc; padding: .5rem; text-align: left; }
        thead { background: #f5f5f5; }
    </style>
</head>
<body>

  <button onclick="location.href='mintnft.html'">Mint NFT</button>
  <button onclick="location.href='viewnft.html'">View NFT</button>

  <h1>Predictive Duel NFT Minter</h1>
  <div id="account">Not connected</div>
  <button id="connect">Connect Wallet</button>
  <hr/>

  <!-- ETH mint section -->
  <label>
    Quantity:
    <input type="number" id="ethCount" min="1" value="1" />
    <span id="ethCost" class="cost">0.5 ETH</span>
  </label>
  <button id="mintEth" disabled>Mint with 0.5 ETH each</button>
  <hr/>

  <!-- USDT mint section -->
  <label>
    Quantity:
    <input type="number" id="usdtCount" min="1" value="1" />
    <span id="usdtCost" class="cost">1 000 USDT</span>
  </label>
  <button id="mintUsdt" disabled>Mint with 1 000 USDT each</button>

  <!-- results table, hidden until a mint succeeds -->
  <table id="mintDetails" style="display: none;">
      <thead>
        <tr>
          <th>Minter</th>
          <th>Token ID</th>
          <th>Rarity</th>
          <th>Paid in ETH?</th>
        </tr>
      </thead>
      <tbody></tbody>
  </table>

  <script type="module">
    import { ethers } from 'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.esm.min.js';
    import { NFT_ADDRESS, USDT_ADDRESS } from "../config.js";

    const nftAddress  = NFT_ADDRESS;
    const usdtAddress = USDT_ADDRESS;

    // ABI must match the new overloads
    const nftAbi = [
      "function mintWithETH() payable",
      "function mintWithUSDT(uint256 amount)",
      "event Minted(address indexed minter, uint256 indexed tokenId, string rarity, bool paidInETH)"
    ];
    const erc20Abi = [
      "function approve(address spender, uint256 amount) returns (bool)",
      "function allowance(address owner, address spender) view returns (uint256)",
      "function decimals() view returns (uint8)"
    ];

    let provider, signer, nftContract, usdtContract;

    const accountEl      = document.getElementById("account");
    const btnConnect     = document.getElementById("connect");
    const btnMintEth     = document.getElementById("mintEth");
    const btnMintUsdt    = document.getElementById("mintUsdt");
    const ethCountInput  = document.getElementById("ethCount");
    const usdtCountInput = document.getElementById("usdtCount");
    const ethCostEl      = document.getElementById("ethCost");
    const usdtCostEl     = document.getElementById("usdtCost");
    const mintDetailsTbl = document.getElementById("mintDetails");
    const mintDetailsTbody = mintDetailsTbl.querySelector("tbody");

    function formatEtherAmount(bn) {
      return ethers.utils.formatEther(bn) + " ETH";
    }

    function formatUsdtAmount(bn, decimals) {
      return ethers.utils.formatUnits(bn, decimals) + " USDT";
    }

    function updateEthCost() {
      const count = Math.max(1, parseInt(ethCountInput.value) || 1);
      const unitPrice = ethers.utils.parseEther("0.5");
      const total = unitPrice.mul(count);
      ethCostEl.textContent = formatEtherAmount(total);
    }

    async function updateUsdtCost() {
      if (!usdtContract) return;
      const count = Math.max(1, parseInt(usdtCountInput.value) || 1);
      const dec = await usdtContract.decimals();
      const unit = ethers.utils.parseUnits("1000", dec);
      const total = unit.mul(count);
      usdtCostEl.textContent = formatUsdtAmount(total, dec);
    }

    function displayMintDetails(minter, tokenId, rarity, paidInETH) {
      mintDetailsTbl.style.display = 'table';
      mintDetailsTbody.insertAdjacentHTML('beforeend', `
        <tr>
          <td>${minter}</td>
          <td>${tokenId.toString()}</td>
          <td>${rarity}</td>
          <td>${paidInETH ? 'Yes' : 'No'}</td>
        </tr>`);
    }

    async function connectWallet() {
      if (!window.ethereum) {
        return alert("Please install MetaMask or another wallet");
      }
      provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      signer = provider.getSigner();
      const [acct] = await provider.listAccounts();
      accountEl.textContent = "Connected: " + acct;

      nftContract  = new ethers.Contract(nftAddress, nftAbi, signer);
      usdtContract = new ethers.Contract(usdtAddress, erc20Abi, signer);

      // subscribe to Minted events
      nftContract.on("Minted", (minter, tokenId, rarity, paidInETH) => {
        console.log("üéâ Minted:", minter, tokenId.toString(), rarity, paidInETH);
        displayMintDetails(minter, tokenId, rarity, paidInETH);
      });

      // enable buttons
      btnMintEth.disabled  = false;
      btnMintUsdt.disabled = false;

      // attach cost update listeners
      ethCountInput.addEventListener("input", updateEthCost);
      updateEthCost();
      usdtCountInput.addEventListener("input", updateUsdtCost);
      updateUsdtCost();
    }

    btnConnect.addEventListener('click', connectWallet);
    window.addEventListener('load', () => {
      if (window.ethereum && window.ethereum.selectedAddress) {
        connectWallet().catch(console.error);
      }
    });

    btnMintEth.addEventListener('click', async () => {
      try {
        const count = Math.max(1, parseInt(ethCountInput.value) || 1);
        const unitPrice = ethers.utils.parseEther("0.5");
        const totalValue = unitPrice.mul(count);

        // static call for revert check
        await nftContract.callStatic.mintWithETH({ value: totalValue });

        const tx = await nftContract.mintWithETH({ value: totalValue });
        accountEl.textContent = `‚õì ETH mint tx sent: ${tx.hash}`;
        await tx.wait();
        accountEl.textContent = "‚úÖ Mint with ETH confirmed!";
      } catch (e) {
        console.error("‚ùå ETH mint error:", e);
        alert("ETH mint failed: " + e.message);
      }
    });

    btnMintUsdt.addEventListener('click', async () => {
      btnMintUsdt.disabled = true;
      try {
        const count = Math.max(1, parseInt(usdtCountInput.value) || 1);
        const dec = await usdtContract.decimals();
        const unit = ethers.utils.parseUnits("1000", dec);
        const amount = unit.mul(count);

        // approve USDT
        const approveTx = await usdtContract.approve(nftAddress, amount);
        accountEl.textContent = `‚õì Approve tx: ${approveTx.hash}`;
        await approveTx.wait();

        accountEl.textContent = `‚úÖ Approved ${count} √ó 1 000 USDT. Minting‚Ä¶`;
        const mintTx = await nftContract.mintWithUSDT(amount);
        accountEl.textContent = `‚õì Mint tx: ${mintTx.hash}`;
        await mintTx.wait();
        accountEl.textContent = "‚úÖ Mint with USDT confirmed!";
      } catch (err) {
        console.error("‚ùå USDT mint error:", err);
        alert("USDT mint failed: " + (err.error?.message || err.message));
      } finally {
        btnMintUsdt.disabled = false;
      }
    });
  </script>

</body>
</html>
